<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>springboot2</title>
    <link href="/2022/03/07/springboot2/"/>
    <url>/2022/03/07/springboot2/</url>
    
    <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><ul><li>SpringBoot快速入门</li><li>SpringBoot基础配置</li><li>基于SpringBoot整合SSMP</li></ul><h2 id="几种搭建SpringBoot的方式"><a href="#几种搭建SpringBoot的方式" class="headerlink" title="几种搭建SpringBoot的方式"></a>几种搭建SpringBoot的方式</h2><ul><li>idea中根据向导进行联网快速制作</li><li>SpringBoot官网制作</li><li>选择start来源为自定义URL <a href="http://start.aliyun.com或https//start.aliyun.com">http://start.aliyun.com或https://start.aliyun.com</a></li><li>手动创建一个maven工程，改造成sprinboot（1.pom 2.引导类)</li></ul><h3 id="在Idea中隐藏指定文件-文件夹"><a href="#在Idea中隐藏指定文件-文件夹" class="headerlink" title="在Idea中隐藏指定文件/文件夹"></a>在Idea中隐藏指定文件/文件夹</h3><p>【Files】-&gt;【Settings】-&gt;【Editor】-&gt;【File Types】-&gt;【Ignored Files and Folders】</p><h2 id="springboot的pom文件"><a href="#springboot的pom文件" class="headerlink" title="springboot的pom文件"></a>springboot的pom文件</h2><ul><li>继承spring-boot-starter-parent(SpringBoot统一管理版本减少依赖冲突的)</li><li>实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter (starter可以实现快速配置的效果)<ul><li>如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供</li><li>如果没有对应的starter，手写坐标即可</li></ul></li></ul><h2 id="springboot中tomcat服务器运行原因"><a href="#springboot中tomcat服务器运行原因" class="headerlink" title="springboot中tomcat服务器运行原因"></a>springboot中tomcat服务器运行原因</h2><p>其实是以对象的形式在Spring容器中运行的(主要是在tomcat-embed-core里)</p><h2 id="更换内嵌Tomcat"><a href="#更换内嵌Tomcat" class="headerlink" title="更换内嵌Tomcat"></a>更换内嵌Tomcat</h2><p>排除掉spring-boot-starter-tomcat 新增一个spring-boot-starter-jetty</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nettyAccept</title>
    <link href="/2022/01/24/nettyAccept/"/>
    <url>/2022/01/24/nettyAccept/</url>
    
    <content type="html"><![CDATA[<h1 id="netty-启动接受新连接"><a href="#netty-启动接受新连接" class="headerlink" title="netty 启动接受新连接"></a>netty 启动接受新连接</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>selector.select()阻塞直到有事件发生</li><li>遍历处理selectedKeys</li><li>判断事件类型是否是accept</li><li>创建SocketChannel,设置为非阻塞</li><li>将SocketChannel注册到selector上</li><li>关注read事件</li></ul><p>##每一步对应的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">判断事件类型是否是accept<br>NioEventLoop 里<span class="hljs-function">processSelectedKey</span><br><span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-params">(readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT</span>)) !</span>= <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">unsafe</span>.read();<br> &#125;<br><span class="hljs-keyword">unsafe</span>类型 AbstractNioMessageChannel<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">创建SocketChannel,设置为非阻塞<br>NioMessageUnsafe read() <br>NioServerSocketChannel doReadMessages<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>     SocketChannel ch = SocketUtils.accept(javaChannel());<br><br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;<br>             buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>         logger.warn(<span class="hljs-string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);<br><br>         <span class="hljs-keyword">try</span> &#123;<br>             ch.close();<br>         &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>             logger.warn(<span class="hljs-string">&quot;Failed to close a socket.&quot;</span>, t2);<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">将SocketChannel注册到selector上<br>pipeline.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">readBuf</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span>);<br>NioServerSocketChannel的pipeline流水线操作，实际处理是由ServerBootstrapAcceptor 的channelRead<br>        public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>            final Channel child = (Channel) msg;<br><br>            child.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">childHandler</span>)</span>;<br><br>            set<span class="hljs-constructor">ChannelOptions(<span class="hljs-params">child</span>, <span class="hljs-params">childOptions</span>, <span class="hljs-params">logger</span>)</span>;<br><br>            <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>                child.attr((AttributeKey&lt;Object&gt;) e.get<span class="hljs-constructor">Key()</span>).set(e.get<span class="hljs-constructor">Value()</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                childGroup.register(child).add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>                    @Override<br>                    public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                        <span class="hljs-keyword">if</span> (!future.is<span class="hljs-constructor">Success()</span>) &#123;<br>                            force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">future</span>.<span class="hljs-params">cause</span>()</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125; catch (Throwable t) &#123;<br>                force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">t</span>)</span>;<br>            &#125;<br>        &#125;<br>        <br><br>        register方法里线程切换<br>            <span class="hljs-keyword">if</span> (eventLoop.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>) &#123;<br>                register0(promise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>                        @Override<br>                        public void run<span class="hljs-literal">()</span> &#123;<br>                            register0(promise);<br>                        &#125;<br>                    &#125;);<br>                &#125; catch (Throwable t) &#123;<br>                    logger.warn(<br>                            <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span></span>this, t);<br>                    close<span class="hljs-constructor">Forcibly()</span>;<br>                    closeFuture.set<span class="hljs-constructor">Closed()</span>;<br>                    safe<span class="hljs-constructor">SetFailure(<span class="hljs-params">promise</span>, <span class="hljs-params">t</span>)</span>;<br>                &#125;<br>            &#125;<br><br>            register0里<span class="hljs-keyword">do</span><span class="hljs-constructor">Register()</span>; 完成NioSocketChannel注册到seletor上，无关注事件<br>            pipeline.invoke<span class="hljs-constructor">HandlerAddedIfNeeded()</span>; 构建NioSocketChannel的pipeline<br>            将hangler添加到pipeline<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">关注read事件  层层调用最后 在AbstractNioChannel类<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>        <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>        <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>        <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        readPending = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>            selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>        &#125;<br>    &#125;<br><br>    其中readInterestOp 是在构建NioSocketChannel时设置的OP_READ<br>    <span class="hljs-keyword">protected</span> AbstractNioByteChannel(Channel parent, SelectableChannel ch) &#123;<br>            <span class="hljs-keyword">super</span>(parent, ch, SelectionKey.OP_READ);<br>    &#125;   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nettyBoot</title>
    <link href="/2022/01/11/nettyBoot/"/>
    <url>/2022/01/11/nettyBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="netty-启动流程"><a href="#netty-启动流程" class="headerlink" title="netty 启动流程"></a>netty 启动流程</h1><p>对比分析一下 </p><h2 id="nio启动步骤"><a href="#nio启动步骤" class="headerlink" title="nio启动步骤"></a>nio启动步骤</h2><ul><li>Selector selector = Selector.open();</li><li>ServerSocketChannel ssc = ServerSocketChannel.open();</li><li>SelectionKey selectionKey = ssc.register(selector,0,nettySsc);</li><li>ssc.bind(new InetSocketAddress(8080,backlog));</li><li>selectionKey.interestOps(SelectionKey.OP_ACCEPT);</li></ul><h2 id="netty启动步骤"><a href="#netty启动步骤" class="headerlink" title="netty启动步骤"></a>netty启动步骤</h2><ul><li>init<ul><li>创建niossc main</li><li>添加初始化handler main<ul><li>初始化hander被调用 (向niossc 添加acceptorHandler)nio-thread</li></ul></li></ul></li><li>register<ul><li>原生ssc注册到seletor 未关注事件 nio-thread</li><li>执行niossc初始化handler nio-thread</li></ul></li><li>bind<ul><li>原生ssc绑定端口 nio-thread</li><li>fire niossc active事件（设置了关注事件)</li></ul></li></ul><h3 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h3><p> 1.初始化handler什么时候被调用?<br> <figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">AbstractChannel类中register0方法里<br>pipeline.invokeHandlerAddedIfNeeded()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br> niossc初始化handler只会执行一次，执行完自动删除<br> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">执行一次<br>DefaultChannelPipeline类中方法<br>final void invoke<span class="hljs-constructor">HandlerAddedIfNeeded()</span> &#123;<br>        <span class="hljs-keyword">assert</span> channel.event<span class="hljs-constructor">Loop()</span>.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>;<br>        <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>            firstRegistration = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span><br>            <span class="hljs-comment">// that were added before the registration was done.</span><br>            call<span class="hljs-constructor">HandlerAddedForAllHandlers()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">自动删除<br>ChannelInitializer类中方法<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (ctx.channel().isRegistered()) &#123;<br>            initChannel(ctx);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                initChannel((C) ctx.channel());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>                <span class="hljs-comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span><br>                <span class="hljs-comment">// We do so to prevent multiple calls to initChannel(...).</span><br>                exceptionCaught(ctx, cause);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                remove(ctx);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>ServerBootStrap 中init 里的<br>p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>                ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>                    pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>                &#125;<br><br>                ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;);<br><br>ServerSocketChannel的pipeline里的<span class="hljs-keyword">handler</span><br>Head-&gt;ServerBootstrapAcceptor-&gt;Tail<br></code></pre></td></tr></table></figure><p>2 创建NioServerSocketChannel</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">通过反射调用NioServerSocketChannel构造方法<br>public T <span class="hljs-keyword">new</span><span class="hljs-constructor">Channel()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        return clazz.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>    &#125; catch (Throwable t) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelException(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + <span class="hljs-params">clazz</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125;<br>最终和Nio创建 ServerSocketChannel ssc = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>调用的同一个类SelectorProviderImpl里的方法<br>public ServerSocketChannel <span class="hljs-keyword">open</span><span class="hljs-constructor">ServerSocketChannel()</span> throws IOException &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerSocketChannelImpl(<span class="hljs-params">this</span>)</span>;<br>&#125;<br><br>为channel构建一个包含head 和 tail 的 pipeline<br>protected <span class="hljs-constructor">AbstractChannel(Channel <span class="hljs-params">parent</span>)</span> &#123;<br>        this.parent = parent;<br>        id = <span class="hljs-keyword">new</span><span class="hljs-constructor">Id()</span>;<br>        unsafe = <span class="hljs-keyword">new</span><span class="hljs-constructor">Unsafe()</span>;<br>        pipeline = <span class="hljs-keyword">new</span><span class="hljs-constructor">ChannelPipeline()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.bind什么时候调用？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">异步调用，<br>  final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>  regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>                @Override<br>                public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                    Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>                    <span class="hljs-keyword">if</span> (cause != null) &#123;<br>                        promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        promise.registered<span class="hljs-literal">()</span>;<br>                        <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>                    &#125;<br>                &#125;<br>            &#125;);<br>  abstractChannel类里的register0方法<br>  safe<span class="hljs-constructor">SetSuccess(<span class="hljs-params">promise</span>)</span>;<br></code></pre></td></tr></table></figure><p>4.哪里设置了OP_ACCEPT事件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">AbstractNioChannel类<br> @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>        <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>        <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>        <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        readPending = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>            selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NIO</title>
    <link href="/2021/12/13/nio/"/>
    <url>/2021/12/13/nio/</url>
    
    <content type="html"><![CDATA[<h2 id="NIO简介"><a href="#NIO简介" class="headerlink" title="NIO简介"></a>NIO简介</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 双向数据通道，可以向通道中读写</p><ul><li>FileChannel  -&gt; 文件传输</li><li>DatagramChannel -&gt; UDP</li><li>ServerSocketChannel -&gt;TCP 只用于服务器</li><li>SocketChannel -&gt;TCP   服务器客户端都用到</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer 数据暂存缓冲区<br>怎么知道是读模式还是写模式呢?<br>无论哪种模式position=limit 进行读写会异常，所有读之前必须flip() ,读完再写入必须clear()</p><ul><li>Capacity </li><li>Position </li><li>Limit </li><li>Mark </li></ul><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>Flip() limit=position position=0<br>Clear() limit=capacity position=0<br>Compact() position = 剩余未读的数据 limit=capacity 未读字节从0开始，原来位置上的数据保持不动</p><ul><li>1 2 3 4</li><li>1 2 已读 </li><li>3 4 3 4 position=2  从第二个3开始写</li></ul><h4 id="读方法-rewind-mark-and-reset"><a href="#读方法-rewind-mark-and-reset" class="headerlink" title="读方法 rewind()     mark() and reset()"></a>读方法 rewind()     mark() and reset()</h4><p>Rewind()  position=0<br>Mark() mark =position标记当前位置<br>Reset() position=mark 从mark开始读</p><h4 id="字符串和ByteBuffer转换-三种方式"><a href="#字符串和ByteBuffer转换-三种方式" class="headerlink" title="字符串和ByteBuffer转换 三种方式"></a>字符串和ByteBuffer转换 三种方式</h4><ul><li>直接放入byte数组   </li><li>StandardCharsets.encode()   -&gt;自动调用flip()切换到读模式</li><li>ByteBuffer.Wrap()                -&gt;自动调用flip()切换到读模式<div class="code-wrapper"><pre><code class="hljs">  ByteBuffer byteBuffer1 = ByteBuffer.allocate(16);  byte[] bytes = &quot;hello&quot;.getBytes();  byteBuffer1.put(bytes);  byteBuffer1.flip();  System.out.println(new String(byteBuffer1.array(), byteBuffer1.position(), byteBuffer1.limit(), &quot;utf-8&quot;));  ByteBuffer byteBuffer2 = StandardCharsets.UTF_8.encode(&quot;hello&quot;);  System.out.println(StandardCharsets.UTF_8.decode(byteBuffer2).toString());  ByteBuffer byteBuffer3 = ByteBuffer.wrap(&quot;hello&quot;.getBytes());  System.out.println(StandardCharsets.UTF_8.decode(byteBuffer3).toString());</code></pre></div></li></ul><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h4 id="单线程模式"><a href="#单线程模式" class="headerlink" title="单线程模式"></a>单线程模式</h4><ul><li>阻塞模式下阻塞方法之间相互影响，不能正常处理多个连接</li><li>非阻塞模式下cpu占用高空轮询</li></ul><h4 id="多线程版本的通讯"><a href="#多线程版本的通讯" class="headerlink" title="多线程版本的通讯"></a>多线程版本的通讯</h4><p>每个socket有单独的线程提供服务</p><ul><li>内存占用高，一个线程默认占用1m内存</li><li>线程上下文切换(线程不为你服务时需要暂存信息，到你了恢复信息)</li><li>只适用于连接数据较少的情况</li></ul><h4 id="线程池版本"><a href="#线程池版本" class="headerlink" title="线程池版本"></a>线程池版本</h4><ul><li>阻塞模式下，一个线程仅仅只是处理一个连接</li><li>仅仅适合短连接场景</li></ul><h4 id="Selector-版本-多路复用模式"><a href="#Selector-版本-多路复用模式" class="headerlink" title="Selector 版本(多路复用模式)"></a>Selector 版本(多路复用模式)</h4><p>Selector 配合一个线程管理多个channel 过去channel上的事件，这些channel工作在非阻塞模式下，不会一直占用<br>线程</p><p>Accept -服务端有连接请求时触发<br>Connect - 客户端连接建立后触发的<br>Read -可读<br>Write-可写</p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝指的是数据无需拷贝到 JVM 内存（用户缓冲区如byte[] ByteBuffer）中，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算</li><li>零拷贝适合小文件传输</li></ul><p>1.Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的用户态切换至内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p>2.从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即 byte[] buf），这期间 CPU 会参与拷贝，无法利用 DMA</p><p>3.调用 write 方法，这时将数据从用户缓冲区（byte[] buf）写入 socket 缓冲区，CPU 会参与拷贝</p><p>4.接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 CPU</p><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><p>用户态与内核态的切换发生了 3 次，这个操作比较重量级<br>数据拷贝了共 4 次</p><h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf<br>减少了一次数据拷贝，用户态与内核态的切换次数没有减少<br>进一步优化1<br>以下两种方式都是零拷贝，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 linux 2.1 后提供的 sendFile 方法，Java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p>Java 调用 transferTo 方法后，要从 Java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 CPU</p><p>数据从内核缓冲区传输到 socket 缓冲区，CPU 会参与拷贝</p><p>最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 CPU</p><p>这种方法下只发生了1次用户态与内核态的切换<br>数据拷贝了 3 次</p><h4 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h4><p>linux 2.4 对上述方法再次进行了优化</p><p>Java 调用 transferTo 方法后，要从 Java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 CPU</p><p>只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗</p><p>使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 CPU</p><p>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建教程</title>
    <link href="/2021/10/28/hexo/"/>
    <url>/2021/10/28/hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo是搭建博客的框架</p><ol><li><p>安装Git</p></li><li><p>安装nodejs</p></li><li><p>安装hexo</p><p> 前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹hexo(随意命名)，在这个文件夹下直接shift+右键打开powershell</p><p> 输入命令</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>-g hexo-cli<br>hexo init <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>cd <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br><span class="hljs-keyword"></span>hexo s <br></code></pre></td></tr></table></figure><p> hexo s 也就是hexo server 代表打开了本地服务在浏览器输入localhost:4000就可以看到你生成的博客了  </p> <img src="/2021/10/28/hexo/zkx.png" class="">  </li><li><p>GitHub创建个人仓库</p><p> 例如用户名是zhangsan 仓库名就是 zhangsan.github.io</p></li><li><p>部署到github  </p><ul><li><p>生成token后续使用(使用用户名密码方式已经被官方删除了，现在只能使用token)<br>  a. 找到自己的repo<br>  b. 找到Settings<br>  c. 找到Developer settings<br>  d. 找到Personal access tokens  新建生成</p></li><li><p>打开hexo目录下的_config.yml<br>deploy:<br>  type: git    注意每个冒号后面都有空格<br>  repo: https: <a href="mailto:&#x74;&#x6f;&#x6b;&#101;&#110;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x74;&#x6f;&#x6b;&#101;&#110;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>/用户名/用户名.github.io.git<br>  branch: master  </p></li><li><p>安装部署工具 hexo-deploy-git    </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>可以写文章了,新建一篇文章 helloworld</p><div class="code-wrapper"><pre><code class="hljs">  hexo new helloworld  </code></pre></div></li></ul><p> 默认会在_posts下生成helloworld.md，然后就可以编辑自己的文章了</p><ul><li><p>写好可以先本地查看  </p><div class="code-wrapper"><pre><code class="hljs">  hexo clean  hexo s</code></pre></div></li><li><p>没啥问题就推送到github</p><div class="code-wrapper"><pre><code class="hljs">  hexo clean  hexo g -d  //g generate缩写生产静态文章 d deploy 缩写 部署到github</code></pre></div></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>diary</title>
    <link href="/2021/10/27/diary/"/>
    <url>/2021/10/27/diary/</url>
    
    <content type="html"><![CDATA[<h2 id="Welcome-to-GitHub-Pages"><a href="#Welcome-to-GitHub-Pages" class="headerlink" title="Welcome to GitHub Pages"></a>Welcome to GitHub Pages</h2><p>You can use the <a href="https://github.com/kexiazhou/kexiazhou.github.io/edit/main/README.md">editor on GitHub</a> to maintain and preview the content for your website in Markdown files.</p><p>Whenever you commit to this repository, GitHub Pages will run <a href="https://jekyllrb.com/">Jekyll</a> to rebuild the pages in your site, from the content in your Markdown files.</p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for</p><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">Syntax highlighted code block<br><br><span class="hljs-section"># Header 1</span><br><span class="hljs-section">## Header 2</span><br><span class="hljs-section">### Header 3</span><br><br><span class="hljs-bullet">-</span> Bulleted<br><span class="hljs-bullet">-</span> List<br><br><span class="hljs-bullet">1.</span> Numbered<br><span class="hljs-bullet">2.</span> List<br><br><span class="hljs-strong">**Bold**</span> and <span class="hljs-emphasis">_Italic_</span> and <span class="hljs-code">`Code`</span> text<br><br>[<span class="hljs-string">Link</span>](<span class="hljs-link">url</span>) and ![<span class="hljs-string">Image</span>](<span class="hljs-link">src</span>)<br></code></pre></td></tr></table></figure><p>1.sssss<br>2.ggggg<br>3.hhhhh<br>-rrrrrr<br>-yyyyyy<br>-uuuuuu<br>For more details see <a href="https://guides.github.com/features/mastering-markdown/">GitHub Flavored Markdown</a>.</p><h3 id="Jekyll-Themes"><a href="#Jekyll-Themes" class="headerlink" title="Jekyll Themes"></a>Jekyll Themes</h3><p>Your Pages site will use the layout and styles from the Jekyll theme you have selected in your <a href="https://github.com/kexiazhou/kexiazhou.github.io/settings/pages">repository settings</a>. The name of this theme is saved in the Jekyll <code>_config.yml</code> configuration file.</p><h3 id="Support-or-Contact"><a href="#Support-or-Contact" class="headerlink" title="Support or Contact"></a>Support or Contact</h3><p>Having trouble with Pages? Check out our <a href="https://docs.github.com/categories/github-pages-basics/">documentation</a> or <a href="https://support.github.com/contact">contact support</a> and we’ll help you sort it out.<br>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>netty</title>
    <link href="/2021/10/27/netty/"/>
    <url>/2021/10/27/netty/</url>
    
    <content type="html"><![CDATA[<h2 id="netty简介"><a href="#netty简介" class="headerlink" title="netty简介"></a>netty简介</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/27/hello-world/"/>
    <url>/2021/10/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
